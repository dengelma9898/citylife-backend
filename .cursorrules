You are a senior TypeScript programmer with experience in the NestJS framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

# TypeScript General Guidelines

## Basic Principles
- Use English for all code and documentation
- Always declare types for variables and functions
- Use JSDoc for public classes and methods
- No blank lines within functions
- One export per file

## Nomenclature
- PascalCase for classes
- camelCase for variables, functions, and methods
- kebab-case for files and directories
- UPPERCASE for environment variables
- Start functions with verbs
- Use verbs for boolean variables (isLoading, hasError, etc.)
- Use complete words instead of abbreviations

## Functions
- Write short functions with single purpose (< 20 lines)
- Name functions with verb + noun
- Use early returns to avoid nesting
- Use higher-order functions (map, filter, reduce)
- Use default parameter values
- Use RO-RO (Receive Object, Return Object) pattern

## Data
- Encapsulate data in composite types
- Use classes with internal validation
- Prefer immutability (readonly, as const)

## Classes
- Follow SOLID principles
- Prefer composition over inheritance
- Declare interfaces for contracts
- Write small classes (< 200 lines, < 10 methods)

## Domain Entities
- Use readonly properties for immutability
- Avoid getter methods, expose properties directly
- Use private constructor with static factory methods
- Implement toJSON for serialization
- Return new instances in update methods
- Example:
```typescript
export interface EntityProps {
  id: string;
  // other properties
}

export class Entity {
  readonly id: string;
  // other readonly properties

  private constructor(props: EntityProps) {
    this.id = props.id;
    // initialize other properties
  }

  static create(props: Omit<EntityProps, 'id'>): Entity {
    return new Entity({
      id: crypto.randomUUID(),
      ...props
    });
  }

  static fromProps(props: EntityProps): Entity {
    return new Entity(props);
  }

  update(props: Partial<Omit<EntityProps, 'id'>>): Entity {
    return new Entity({
      ...this,
      ...props
    });
  }

  toJSON(): EntityProps {
    return {
      id: this.id,
      // other properties
    };
  }
}
```

## Exceptions
- Use exceptions for unexpected errors
- Catch exceptions to:
  - Fix expected problems
  - Add context
  - Use global handler otherwise

## Testing
- Follow Arrange-Act-Assert
- Name test variables clearly
- Write unit tests for public functions
- Write acceptance tests for modules

# NestJS Specific Guidelines

## Basic Principles
- Use modular architecture
- Encapsulate API in modules
- One module per main domain/route
- One controller per route
- Models folder with data types
- Services module for business logic
- Core module for NestJS artifacts
- Shared module for shared services

## Authentication
- **IMPORTANT**: All users are always authenticated (at minimum anonymously)
- The AuthGuard expects an Authorization header on all requests
- Users authenticate via Firebase Auth, including anonymous authentication
- There are no public endpoints without authentication - all endpoints require a valid Firebase token
- Anonymous users are automatically created by the client apps and have valid Firebase tokens

## Authorization (RolesGuard)
- **IMPORTANT**: Modules that use `@UseGuards(RolesGuard)` in their controllers MUST import `UsersModule`
- The `RolesGuard` requires `UsersService` as a dependency to check user roles
- If a module uses `RolesGuard` but doesn't import `UsersModule`, the endpoints will return 404 errors
- Example: If `AppVersionsAdminController` uses `@UseGuards(RolesGuard)`, then `AppVersionsModule` must import `UsersModule`
- Always check if controllers use `RolesGuard` and ensure the module imports `UsersModule`

## Testing
- Use Jest framework
- Write tests for controllers and services
- Write end-to-end tests for API modules
- Add admin/test method to controllers

# Feature Development Guidelines

## Notifications
- **IMPORTANT**: When implementing a new feature that involves user interactions or events, always ask:
  "Should this feature send push notifications to users?"
- If notifications are needed:
  - Use the existing `NotificationService` from `NotificationsModule`
  - Follow the notification payload structure defined in `NotificationPayload` interface
  - Create a new notification data interface in `src/notifications/domain/interfaces/` for each notification type
  - Always check user notification preferences before sending (default: enabled if undefined)
  - Consider mute functionality for user-specific notifications (e.g., muted chats)
  - Document notification behavior in feature documentation
- **Notification Types**:
  - `DIRECT_CHAT_MESSAGE`: Sent when a new message is received in a direct chat
  - `NEW_BUSINESS`: Sent when a new business becomes active (created with ACTIVE status or changed from PENDING to ACTIVE)
- **Notification Preferences**:
  - Stored in `UserProfile.notificationPreferences` (Firebase Firestore `users` collection)
  - Structure: `{ directMessages?: boolean, newBusinesses?: boolean, directChatRequests?: boolean }`
  - Default: `false` if preference is undefined (Notifications werden nur gesendet, wenn PrÃ¤ferenz explizit auf `true` gesetzt ist)
  - Update endpoint: `PATCH /users/:id/profile` with `notificationPreferences` in body
- **Module Dependencies**:
  - `NotificationsModule` imports `UsersModule` with `forwardRef()` due to circular dependencies
  - Services injecting `UsersService` in modules with circular dependencies must use `@Inject(forwardRef(() => UsersService))`
  - Example: `BusinessesService` uses `@Inject(forwardRef(() => UsersService))` for `UsersService` injection
- **FCM Token Management**:
  - Tokens stored in `UserProfile.fcmTokens[]` array (multi-device support)
  - Register: `POST /users/:id/fcm-token` with `{ token, deviceId, platform }`
  - Remove: `DELETE /users/:id/fcm-token/:deviceId`
  - Tokens automatically cleaned up when invalid (handled by `FcmNotificationService`)
- **Implementation Pattern**:
  ```typescript
  // 1. Inject NotificationService and UsersService
  constructor(
    private readonly notificationService: NotificationService,
    @Inject(forwardRef(() => UsersService))
    private readonly usersService: UsersService,
  ) {}
  
  // 2. Check preferences before sending
  const preferences = userProfile.notificationPreferences;
  const enabled = preferences?.newFeatureType !== undefined 
    ? preferences.newFeatureType 
    : true; // default
  
  // 3. Send notification
  await this.notificationService.sendToUser(userId, {
    title: 'Notification Title',
    body: 'Notification body text',
    data: {
      type: 'NOTIFICATION_TYPE',
      // ... type-specific data
    },
  });
  ```
- Examples of features that might need notifications:
  - New messages in chats
  - Event invitations
  - Business offers
  - Job applications
  - Comments/reactions on posts

# Firebase Persistence Guidelines

## Data Conversion Rules
- Convert undefined to null before saving to Firebase
- Convert class instances to plain objects
- Handle Firebase Timestamps correctly

## Repository Implementation
```typescript
// Required methods for Firebase repositories
private removeUndefined(obj: any): any {
  if (obj === null || obj === undefined) return null;
  if (Array.isArray(obj)) return obj.map(item => this.removeUndefined(item));
  if (typeof obj === 'object') {
    const result: any = {};
    for (const key in obj) {
      result[key] = this.removeUndefined(obj[key]);
    }
    return result;
  }
  return obj;
}

private toPlainObject(entity: any) {
  const { id, ...data } = entity;
  return this.removeUndefined(data);
}

private toEntityProps(data: any, id: string) {
  return {
    id,
    ...data,
    createdAt: data.createdAt?.toDate?.() || data.createdAt,
    updatedAt: data.updatedAt?.toDate?.() || data.updatedAt
  };
}
```

## Best Practices
- Always use removeUndefined before saving
- Clear separation between domain entities and Firebase data
- Validate data before saving
- Handle Firebase-specific errors
- Implement proper logging
- Use transactions for complex operations
- Use batch operations for multiple documents
- Implement caching strategies
- Create indexes for frequently queried fields

# Code Quality & Maintenance Guidelines

## .cursorrules Maintenance
- **IMPORTANT**: After implementing a new feature or significant change, review `.cursorrules` for necessary updates
- Only add meaningful, actionable rules that will help future development
- Keep rules focused and avoid redundancy
- **File Size Guidelines**:
  - Target: Keep `.cursorrules` under 500 lines
  - Maximum safe size: ~800 lines
  - If exceeding limits, consider splitting into multiple focused rule files
  - Current file should be checked against these limits after each major update
- When updating rules:
  - Add concrete examples and file references
  - Include relevant code patterns and anti-patterns
  - Document architectural decisions and their rationale
  - Remove outdated or conflicting rules
  - Ensure rules are scoped appropriately (project-wide vs. domain-specific)
